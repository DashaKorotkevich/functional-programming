# Лабораторная работа №1: Динамическое программирование

## Задание №1: Решение задач Leetcode

### 1. Climbing Stairs (Восхождение по лестнице)

**Задача:** Найти количество способов подняться на n-ю ступеньку, если за один шаг можно подняться на 1 или 2 ступеньки.

**Решение:**
```javascript
var climbStairs = function(n) {
    if (n <= 1) return 1;
    
    let prev1 = 1;  // для n-1
    let prev2 = 1;  // для n-2
    let current;
    
    for (let i = 2; i <= n; i++) {
        current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    
    return current;
};
```

**Анализ сложности:**
- **Время:** O(n)
- **Память:** O(1)

### 2. Jump Game II (Игра с прыжками 2)

**Задача:** Найти минимальное количество прыжков для достижения последнего элемента массива.

**Решение:**
```javascript
var jump = function(nums) {
    const n = nums.length;
    let jumps = 0;
    let currentEnd = 0;
    let farthest = 0;
    
    for (let i = 0; i < n - 1; i++) {
        farthest = Math.max(farthest, i + nums[i]);
        
        if (i === currentEnd) {
            jumps++;
            currentEnd = farthest;
            
            if (currentEnd >= n - 1) break;
        }
    }
    
    return jumps;
};
```

**Анализ сложности:**
- **Время:** O(n)
- **Память:** O(1)

### 3. Pascal's Triangle II (Треугольник Паскаля II)

**Задача:** Вернуть k-ю строку треугольника Паскаля.

**Решение:**
```javascript
var getRow = function(rowIndex) {
    const row = new Array(rowIndex + 1).fill(0);
    row[0] = 1;
    
    for (let i = 1; i <= rowIndex; i++) {
        for (let j = i; j > 0; j--) {
            row[j] += row[j - 1];
        }
    }
    
    return row;
};
```

**Анализ сложности:**
- **Время:** O(k²)
- **Память:** O(k)

### 4. Best Time to Buy and Sell Stock (Лучшее время для покупки и продажи акций)

**Задача:** Найти максимальную прибыль от одной транзакции.

**Решение:**
```javascript
var maxProfit = function(prices) {
    if (prices.length < 2) return 0;
    
    let minPrice = prices[0];
    let maxProfit = 0;
    
    for (let i = 1; i < prices.length; i++) {
        minPrice = Math.min(minPrice, prices[i]);
        maxProfit = Math.max(maxProfit, prices[i] - minPrice);
    }
    
    return maxProfit;
};
```

**Анализ сложности:**
- **Время:** O(n)
- **Память:** O(1)

### 5. Best Time to Buy and Sell Stock II (Лучшее время для покупки и продажи акций II)

**Задача:** Найти максимальную прибыль от неограниченного количества транзакций.

**Решение:**
```javascript
var maxProfit = function(prices) {
    let profit = 0;
    
    for (let i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            profit += prices[i] - prices[i - 1];
        }
    }
    
    return profit;
};
```

**Анализ сложности:**
- **Время:** O(n)
- **Память:** O(1)

---

## Задание №2: Методология и теоретические основы

### 1. Что такое динамическое программирование?

**Динамическое программирование (ДП)** — это метод решения сложных задач путем разбиения их на более простые подзадачи. Основная идея заключается в том, чтобы не решать одни и те же подзадачи многократно, а сохранять их решения для повторного использования.

**Ключевые характеристики ДП:**
- **Оптимальная подструктура:** Решение задачи может быть составлено из решений подзадач
- **Перекрывающиеся подзадачи:** Одни и те же подзадачи решаются многократно
- **Запоминание результатов:** Сохранение решений подзадач для избежания повторных вычислений

**Пример из задачи Climbing Stairs:**
```
ways(n) = ways(n-1) + ways(n-2)
```
Вместо вычисления каждого значения многократно, мы сохраняем предыдущие результаты.

### 2. Что такое Big O Notation?

**Big O Notation** — это математическая нотация, описывающая асимптотическое поведение функций. В программировании она используется для анализа эффективности алгоритмов по времени выполнения и использованию памяти.

**Основные сложности:**
- **O(1)** — Константное время (постоянное)
- **O(log n)** — Логарифмическое время
- **O(n)** — Линейное время
- **O(n²)** — Квадратичное время
- **O(2ⁿ)** — Экспоненциальное время

**Примеры из решенных задач:**
- Climbing Stairs: O(n) — один проход по циклу
- Pascal's Triangle: O(k²) — вложенные циклы
- Jump Game: O(n) — один проход по массиву

### 3. Что такое мемоизация в рекурсии?

**Мемоизация** — это техника оптимизации, при которой результаты дорогостоящих вызовов функций сохраняются и возвращаются из кеша при повторных вызовах с теми же параметрами.

**Пример мемоизации для чисел Фибоначчи:**

```javascript
// Без мемоизации (медленно)
function fib(n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2); // Много повторных вычислений
}

// С мемоизацией (быстро)
function fibMemo(n, memo = {}) {
    if (n <= 1) return n;
    if (memo[n]) return memo[n];
    
    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);
    return memo[n];
}
```

**Преимущества мемоизации:**
- Уменьшение времени выполнения
- Избежание повторных вычислений
- Преобразование экспоненциальной сложности в полиномиальную

## Выводы

В ходе лабораторной работы были успешно решены 5 задач с использованием динамического программирования. Все решения оптимизированы по времени и используют оптимальные подходы. Были изучены и применены на практике ключевые концепции ДП, анализ сложности алгоритмов и техники оптимизации рекурсивных решений через мемоизацию.


